## 驻留机制

涉及开发时程序不能正常使用的可能性

+ 存在意义：节省内存，提高效率

==：判断等号两边内容是否相同

is：判断两边值的内存地址是否相同

驻留机制顺序：代码块----->小数据池（理解为代码块与代码块之间）

+ 代码块驻留机制（pycharm中测试）

  定义：一个py文件，一个函数，一个模块，一个类，交互模式（终端）下的每一行

  以下情况内存地址相同

  + 数字：-5~正无穷（实际上-5~256的内存地址在所有地方都相同）

    ```
    a = 256
    b = 256
    print(a is b) #True
    print(id(a),id(b)) #1516347472 1516347472  相同（固定地址）
    ```

    ```
    a = 257
    b = 257
    print(a is b) #True
    print(id(a),id(b)) #3075275480848 3075275480848  相同（可变地址）
    ```

    ```
    a = -6
    b = -6
    print(a is b) #False
    print(id(a),id(b)) #2228967021296 2228967021200 不相同（可变地址）
    ```
    
  + 字符串
  
    + 定义时内容相同，内存地址就相同
  
      ```
      a = "123中文english%*-"
      b = "123中文english%*-"
      print(a is b) #True
      print(id(a),id(b)) #2064241611472 2064241611472 相同（可变地址）
      ```
  
    + 进行乘法时（不能有中文和特殊符号-乘0/1时除外-理解为字符串清空与本身），总长度不能超过20
  
      ```
      a = "123中文english%*-" * 1
      b = "123中文english%*-" * 1
      print(a is b) #True
      print(id(a),id(b)) #2518570390224 2518570390224 相同（可变地址）
      ```
  
      ```
      a = "12中eng%*-" * 2 #有中文及特殊符号
      b = "12中eng%*-" * 2
      print(a is b)  #False
      print(id(a),id(b)) #2180300624592 2180300625376 不相同（可变地址）
      ```
  
      ```
      a = "123englis" * 2
      b = "123englis" * 2
      print(a is b) #True
      print(id(a),id(b)) #2420451431240 2420451431240 相同（可变地址）
      ```
  
      ```
      a = "123englis66666" * 2 #总长度超限
      b = "123englis66666" * 2
      print(a is b)   #False
      print(id(a),id(b)) #1923061610656 1923061830800 不相同（可变地址）
      ```
  
+ 小数据池驻留机制（终端中测试）

  代码块与代码块之间实行小数据池驻留机制

  以下情况内存地址相同

  + 数字： -5~256 内存地址固定（任何地方都相同）

    ```
    >>> a = 1
    >>> b = 1
    >>> print(a is b)
    True
    >>> print(id(a),id(b))
    1531740272 1531740272 #相同（固定地址）
    ```

    ```
    >>> a = 257
    >>> b = 257
    >>> print(a is b)
    False
    >>> print(id(a),id(b))
    2544622726000 2544622468944 #不相同（可变地址）
    ```

  + 字符串

    + 定义时为纯数字或字母时内存地址相同

      ```
      >>> a = "123aa"
      >>> b = "123aa"
      >>> print(a is b)
      True
      >>> print(id(a),id(b))
      2544623459496 2544623459496 #相同（可变地址）
      ```

    + Python36进行乘法时（不能有中文和特殊符号-乘0时除外-理解为字符串清空），总长度不能超过20

      ```
      >>> a = "www+1" * 0
      >>> b = "www+1" * 0
      >>> print(a,b)
      
      >>> print(a is b)
      True
      >>> print(id(a),id(b))
      1714965740208 1714965740208 #相同（可变地址）
      ```

      

    + Python37进行乘法时（不能有中文和特殊符号-乘0时除外-理解为字符串清空），总长度不能超过4096

## 深浅拷贝

+ 作用

  + 后期开发代码时避免出现问题，不知道原因
  + 面试（赋值？浅拷贝？深拷贝？）

+ 赋值

  多个变量名指向同一个内存地址

  + 不可变数据类型：新开空间

    ```
    a = 10 
    b = a # a,b 都指向10的内存地址
    a = 11 #对a赋值不影响b
    print(a,b)
    print(id(a),id(b)) #不同
    ```

  + 可变数据类型:原地修改

    ```
    lst =[1,2,3] #可变数据类型
    lst1 = lst #lst,lst1 都指向列表的内存地址
    print(lst,lst1) #[1, 2, 3] [1, 2, 3]
    lst.append(4)
    lst = [1,2,3,4]
    print(lst,lst1) #[1, 2, 3, 4] [1, 2, 3, 4]
    print(id(lst),id(lst1)) #不同
    ```

    ```
    dic = {"key":11,"key2":[1,2,3]}
    dic1 = dic #dic,dic1都指向字典的内存地址，理解为新的引用
    dic["key2"].append(5) #两字典同步修改
    del dic["key"] #两字典同步修改
    print(dic,dic1) #{'key2': [1, 2, 3, 5]} {'key2': [1, 2, 3, 5]}
    print(id(dic),id(dic1)) #地址相同，可变，但不是同一数据？
    ```

+ 浅拷贝

  只拷贝第一层的内存地址，可变和不可变的数据都是共用的，能看到是因为通过内存地址去查找值然后显示的（貌似元素值遵循代码块的驻留机制）

  + copy（）

    ````
    lst = [1,2,3]
    lst1 = lst.copy()  #复制,新的列表
    print(lst,lst1) #[1, 2, 3] [1, 2, 3]
    lst1.append(4) #lst1追加，不影响lst
    print(lst,lst1) #[1, 2, 3] [1, 2, 3, 4]
    print(id(lst),id(lst1)) #不同，可变
    print(id(lst[0]),id(lst1[0]),id(1)) #1530757232 相同 固定
    ````

  + 切片

    ```
    lst = [1,2,[3,4]]
    lst1 = lst[:] #只拷贝第一层
    print(id(lst),id(lst1)) #不同
    print(id(lst[-1]),id(lst1[-1])) #两列表中的列表元素地址相同
    lst1[-1].append(5)
    print(lst,lst1) #[1, 2, [3, 4, 5]] 相同（对相同地址的操作）
    print(id(lst[-1]),id(lst1[-1])) #地址不变
    ```

+ 深拷贝

  不可变数据，元素共用内存地址；

  可变数据类型开辟新的空间，不管嵌套多少层都是这样的原理（理解为互相不会影响）

  ```
  import copy  #导入copy模块
  lst = [-111,-111,[3,4]]
  lst1 = copy.deepcopy(lst)  #深拷贝
  print(id(lst),id(lst1)) #外壳不一样
  print(id(lst[0]),id(lst1[0]))   #不可变数据  --共用
  print(id(lst[1]),id(lst1[1]))   #不可变数据  --共用，开始定义过是不同地址，复制出来的是用相同地址
  print(id(lst[-1]),id(lst1[-1]))  #可变数据--新开辟空间
  print(id(lst[-1][-1]),id(lst1[-1][-1]))  #里面的不可变数据  --共用
  ```

## 集合

+ 定义

  + python数据类型，无序，可变，可迭代
  + 关键字 set
  + 空集合 set()   s = {1,2,3,4}
  + 集合的元素是不可变的（可哈希）、唯一的（理解为没有值的字典）

+ 作用

  + 去重

    ```
    lst = [1,2,1]
    print(list(set(lst))) #[1, 2]
    ```

  + 容器：存储数据

+ 操作

  + 增

    ```
    s = set()
    s.update("alex") #迭代添加
    s.add("alex") #直接添加
    print(s)
    ```

  + 删

    ```
    s = {"0","1","2","3"}
    s.pop() #随机删除 pop具有返回值
    s.remove("0")  #指定元素删除
    s.clear() #清空 后的显示set()
    print(s)
    ```

  + 改

    + 先删后加
    + 转换数据类型进行修改

  + 查

    + for循环
    + 直接打印

+ 集合关系

  + 并集 |
  + 交集 &
  + 补集 ^
  + 差集 -
  + 父集(超集) >  判断
  + 子集 <  判断

  ```
  python = {"海绵","一帆","心累","大圣"}
  linux = {"海绵","大圣","哈哈哈","嘿嘿嘿"}
  print(python | linux)  #并集 {'嘿嘿嘿', '大圣', '哈哈哈', '海绵', '一帆', '心累'}
  print(python & linux)  #交集 {'海绵', '大圣'}
  print(python ^ linux)  #补集 {'嘿嘿嘿', '哈哈哈', '一帆', '心累'}
  print(python - linux)  #差集 {'一帆', '心累'}
  print(linux - python )  #差集 {'嘿嘿嘿', '哈哈哈'}
  ```

  ```
  python = {"海绵","一帆","心累","大圣"}
  linux = {"海绵","大圣"}
  print(python > linux) #判断python是不是linux的超集 True
  print(python < linux) #判断python是不是linux的子集 False
  ```

  