## QQ登录

我们所说的第三方登录，是指用户可以不在本项目中输入密码，而直接通过第三方的验证，成功登录荏苒网。

要开发第三方登录功能，必须要成为QQ互联开发者后，创建应用，即获取当前项目与QQ互联的应用ID，创建应用的方法参考链接<http://wiki.connect.qq.com/__trashed-2>

![1578390841684](F:/Python%E5%AD%A6%E4%B9%A0/%E8%80%81%E7%94%B7%E5%AD%A9%E7%9B%B8%E5%85%B3/%E6%AD%A3%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91/Python-vue-%E8%8D%8F%E8%8B%92%E9%A1%B9%E7%9B%AEday107/day021/assets/1578390841684.png)

申请创建开发应用以后, 需要经过人工审核,这个时间一般是一个工作日或者半个工作日. 

审核的状态会影响我们开发者开发第三方登录,状态有三种:

```
1. 不通过和未审核的应用,是无法开发QQ第三方登录功能的.
2. 只有已通过的应用才可以开发
```

点击刚才申请的引用,进入到项目里面获取APPID和APP KEY.

![1578391088823](F:/Python%E5%AD%A6%E4%B9%A0/%E8%80%81%E7%94%B7%E5%AD%A9%E7%9B%B8%E5%85%B3/%E6%AD%A3%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91/Python-vue-%E8%8D%8F%E8%8B%92%E9%A1%B9%E7%9B%AEday107/day021/assets/1578391088823.png)

QQ登录开发文档连接<http://wiki.connect.qq.com/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C_oauth2-0>

### QQ第三方登录的实现流程

![QQ第三方登录的实现流程.png](F:/Python%E5%AD%A6%E4%B9%A0/%E8%80%81%E7%94%B7%E5%AD%A9%E7%9B%B8%E5%85%B3/%E6%AD%A3%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91/Python-vue-%E8%8D%8F%E8%8B%92%E9%A1%B9%E7%9B%AEday107/day021/assets/QQ%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B.png)



### 创建模型类

创建一个新的应用oauth，用来实现QQ第三方认证登录。

```python
cd renranapi/apps
python ../../manage.py startapp oauth
```

注册子应用 settings/dev.py,代码:

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'corsheaders',
    'xadmin',
    'crispy_forms',
    'reversion',
    'rest_framework',
    
    'users',
    'oauth',
]
```



在models.py中定义QQ身份（openid）与用户模型类User的关联关系

```python
from django.db import models

# Create your models here.
from django.db import models
from renranapi.utils.models import BaseModel
from users.models import User
class OAuthUser(BaseModel):
    """
    登录用户数据
    """
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='用户')
    openid = models.CharField(max_length=64, verbose_name='openid', db_index=True)
    access_token = models.CharField(max_length=500,verbose_name="临时访问票据", help_text="有效期:3个月")
    refresh_token = models.CharField(max_length=500,verbose_name="刷新访问票据的token", help_text="当access_token以后,可以使用refresh_token来重新获取新的access_token")
    class Meta:
        db_table = 'rr_oauth_qq'
        verbose_name = 'QQ登录用户数据'
        verbose_name_plural = verbose_name
```

在utils/models.py，创建项目的公共模型

```python
from django.db import models

class BaseModel(models.Model):
    """基本公共模型"""
    orders = models.IntegerField(default=0, null=True, blank=True, verbose_name="排序")
    is_show = models.BooleanField(default=True, verbose_name="是否展示")
    is_deleted = models.BooleanField(default=False, verbose_name="是否删除")
    created_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_time = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        abstract = True
```



进行数据库迁移

```shell
python manage.py makemigrations
python manage.py migrate
```



### urllib使用说明

在后端接口中，我们需要向QQ服务器发送请求，查询用户的QQ信息，Python提供了标准模块urllib可以帮助我们发送http请求。

- urllib.parse.urlencode(query)

  将query字典转换为url路径中的查询字符串

- urllib.parse.parse_qs(qs)

  将qs查询字符串格式数据转换为python的字典[注意：转换后的字典，值是列表格式]

- urllib.request.urlopen(url, data=None)

  发送http请求，如果data为None，发送GET请求，如果data不为None，发送POST请求

  返回response响应对象，可以通过read()读取响应体数据，需要注意读取出的响应体数据为bytes类型【需要decode】



### 服务端代码实现

#### 配置

+ 在settings/dev.py中增加QQ登录相关配置

  ```python
  # QQ登录参数
  QQ_APP_ID = '101403367'
  QQ_APP_KEY = '93112df14c10d6fde74baa62f5de95ab'
  QQ_REDIRECT_URL = 'http://www.moluo.net:8080/oauth_callback.html'
  QQ_STATE = "/" # 用于保存登录成功后的跳转页面路径
  ```

#### 编写辅助类

在oauth子应用下，创建utils.py文件，编写QQ登录的辅助类

+ 版本1

  ```python
  from urllib.request import urlopen
  from django.conf import settings
  from urllib.parse import urlencode, parse_qs
  import logging
  import json
  
  logger =logging.getLogger("django")
  
  class OAuthQQError(Exception):
      pass
  
  class OAuthQQ(object):
      """QQ第三方登录的辅助类"""
      def __init__(self, app_id=None, app_key=None, redirect_uri=None, state=None):
          self.app_id = app_id or settings.QQ_APP_ID     # 应用ID
          self.app_key = app_key or settings.QQ_APP_KEY  #　应用秘钥　
          self.redirect_url = redirect_uri or settings.QQ_REDIRECT_URL # 回调域名
          self.state = state or settings.QQ_STATE  # 用于保存登录成功后的跳转页面路径
  
      def get_auth_url(self):
          """生成QQ第三方登录的链接"""
          params = {
              'response_type': 'code', # 授权类型
              'client_id': self.app_id,
              'redirect_uri': self.redirect_url, # 回调域名
              'state': self.state,     # 自定义状态
              'scope': 'get_user_info', # 可选，可以不填
          }
  
          url = 'https://graph.qq.com/oauth2.0/authorize?' + urlencode(params)
  
          return url
  
      def get_access_token(self,code):
          """通过授权码获取临时票据access_token"""
          params = {
              'grant_type': 'authorization_code',
              'client_id': self.app_id,
              'client_secret': self.app_key,
              'redirect_uri': self.redirect_url,
              'code': code,
          }
          # urlencode 把字典转换成查询字符串的格式
          url = 'https://graph.qq.com/oauth2.0/token?' + urlencode(params)
          try:
              response = urlopen(url)
              response_data = response.read().decode()
              # parse_qs　把查询字符串格式的内容转换成字典[注意：转换后的字典，值是列表格式]
              data = parse_qs(response_data)
              access_token = data.get('access_token')[0]
          except:
              logger.error('code=%s msg=%s' % (data.get('code'), data.get('msg')))
              raise OAuthQQError
  
          return access_token
  
      def get_open_id(self,access_token):
          """根据access_token获取openID"""
          url = 'https://graph.qq.com/oauth2.0/me?access_token=' + access_token
          try:
              response = urlopen(url)
              response_data = response.read().decode()
              data = json.loads(response_data[10:-4])
              openid = data.get('openid')
          except:
              logger.error('code=%s msg=%s' % (data.get('code'), data.get('msg')))
              raise OAuthQQError
  
          return openid
  
      def get_qq_user_info(self, access_token, openid):
          params = {
              'access_token': access_token,
              'oauth_consumer_key': self.app_id,
              'openid': openid,
          }
          url = 'https://graph.qq.com/user/get_user_info?' + urlencode(params)
          try:
              response = urlopen(url)
              response_data = response.read().decode()
              data = json.loads(response_data)
              return data
          except:
              logger.error('code=%s msg=%s' % (data.get('code'), data.get('msg')))
              raise OAuthQQError
  ```

+ 版本2

  ```python
  from urllib.parse import urlencode, parse_qs
  from urllib.request import urlopen
  from django.conf import settings
  import logging
  import json
  
  logger = logging.getLogger('django')
  
  class OAuthQQTokenError(Exception):
      pass
  
  class OAuthQQOpenIDError(Exception):
      pass
  
  class OAuthQQUserInfoError(Exception):
      pass
  
  class OAuthQQ(object):
      """
      QQ认证辅助工具类
      """
  
      def __init__(self, app_id=None, app_key=None, redirect_uri=None, state=None, code=None, access_token=None,
                   refresh_token=None):
          self.app_id = app_id or settings.QQ_APP_ID
          self.app_key = app_key or settings.QQ_APP_KEY
          self.redirect_url = redirect_uri or settings.QQ_REDIRECT_URL
          self.state = state or settings.QQ_STATE  # 用于保存登录成功后的跳转页面路径
          self.code = code  # 访问url后返回的code
          self._access_token = access_token
          self._refresh_token = refresh_token
          self._open_id = None
  
      @property
      def auth_url(self):
          """
          获取qq登录的网址
          :return: url网址
          """
          params = {
              'response_type': 'code',
              'client_id': self.app_id,
              'redirect_uri': self.redirect_url,
              'state': self.state,
              'scope': 'get_user_info',
          }
          url = 'https://graph.qq.com/oauth2.0/authorize?' + urlencode(params)
          return url
  
      def get_token(self):
          """通过授权码获取临时票据access_token、refresh_token"""
          params = {
              'grant_type': 'authorization_code',
              'client_id': self.app_id,
              'client_secret': self.app_key,
              'redirect_uri': self.redirect_url,
              'code': self.code,
          }
          # urlencode 把字典转换成查询字符串的格式
          url = 'https://graph.qq.com/oauth2.0/token?' + urlencode(params)
          try:
              response = urlopen(url)
              response_data = response.read().decode()
              # parse_qs　把查询字符串格式的内容转换成字典[注意：转换后的字典，值是列表格式]
              data = parse_qs(response_data)
              self._access_token = data.get('access_token')[0]
              self._refresh_token = data.get('refresh_token')[0]
          except:
              logger.error('code=%s msg=%s' % (self.code, "获取access_token、refresh_token失败。"))
              raise OAuthQQTokenError("无效的code！")
  
          return self._access_token
  
      @property
      def access_token(self):
          if not self._access_token:
              self.get_token()
          return self._access_token
  
      @property
      def refresh_token(self):
          if not self._refresh_token:
              self.get_token()
          return self._refresh_token
  
      def get_open_id(self):
          """根据access_token获取openID"""
          url = 'https://graph.qq.com/oauth2.0/me?access_token=' + self.access_token
          try:
              response = urlopen(url)
              response_data = response.read().decode()
              data = json.loads(response_data[10:-4])
              self._open_id = data.get('openid')
          except:
              logger.error('code=%s msg=%s' % (self.code, "获取open_id失败。"))
              raise OAuthQQOpenIDError
  
          return self._open_id
  
      @property
      def open_id(self):
          if not self._open_id:
              self.get_open_id()
          return self._open_id
  
      @property
      def qq_user_info(self):
          params = {
              'access_token': self.access_token,
              'oauth_consumer_key': self.app_id,
              'openid': self.open_id,
          }
          url = 'https://graph.qq.com/user/get_user_info?' + urlencode(params)
          try:
              response = urlopen(url)
              response_data = response.read().decode()
              data = json.loads(response_data)
              return data
          except:
              logger.error('code=%s msg=%s' % (self.code, "获取qq号码用户详细信息失败。"))
              raise OAuthQQUserInfoError
  
  ```

#### 视图主逻辑

视图调用辅助类完成获取QQ用户信息的逻辑

+ 使用版本1

  ```python
  from rest_framework.views import APIView
  from .utils import OAuthQQ,OAuthQQError
  from rest_framework.response import Response
  from .models import OAuthUser
  
  class OAuthQQAPIView(APIView):
      def get(self, request):
          """生成QQ登录的地址"""
          state = request.query_params.get('state') # 客户端指定的状态
          oauth = OAuthQQ(state=state)
          url = oauth.get_auth_url()
          print(url)
          return Response(url)
  
  from itsdangerous import TimedJSONWebSignatureSerializer as Serializer, BadData
  from django.conf import settings
  from renranapi.settings import constants
  class QQInfoAPIView(APIView):
      def get(self,request):
          """获取QQ用户的信息"""
          # 1. 获取客户端转发过来的QQ登录授权码
          code = request.query_params.get("code")
          state = request.query_params.get('state')  # 客户端指定的状态
          if not code:
              return Response("QQ登录异常！请重新尝试登录！")
  
          oauth = OAuthQQ(state=state)
          try:
              # 2. 根据授权码到QQ服务器获取access_token
              access_token = oauth.get_access_token(code)
              # 3. 根据access_token获取用户信息[openID]
              openid = oauth.get_open_id(access_token)
              # 3.1 获取用户信息
              user_info = oauth.get_qq_user_info(access_token,openid)
              # 4F65D2442D41B0D1639FD7FC14123B11
  
          except OAuthQQError:
              return Response("QQ登录异常！获取授权信息失败！请重新尝试登录！")
  
          # 4. 根据openID到数据库中查询用户判断是否属于第一次使用QQ登录
          try:
              oauth_qq_user = OAuthUser.objects.get(openid=openid)
              # 查找到对应的用户记录，证明用户创建我们网站的账号并且已经关联了QQ的openID
              user = oauth_qq_user.user
              # 生成jwt登录token
              from rest_framework_jwt.settings import api_settings
              jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
              jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER
  
              payload = jwt_payload_handler(user)
              token = jwt_encode_handler(payload)
              print(token)
              user_info = {
                  "token":token,
                  "id":user.id,
                  "username":user.username,
                  "avatar":user.avatar.url,
                  "nickname":user.nickname,
              }
              return Response({"user_info": user_info,"status": 1})
          except OAuthUser.DoesNotExist:
              # 查找不到对应的用户记录，用户属于第一次使用QQ登录
              # 使用itsdangrous对数据进行加密
              serializer = Serializer(settings.SECRET_KEY, constants.DATA_SIGNATURE_EXPIRE)
              data = serializer.dumps({"openid": openid}).decode()
              return Response({
                  "avatar": user_info.get("figureurl_qq_1"),
                  "nickname": user_info.get("nickname"),
                  "data": data,
                  "status": 0,
              })
  
  ```

+ 版本2

  ```python
  from rest_framework.views import APIView
  from .utils import OAuthQQ, OAuthQQTokenError, OAuthQQOpenIDError, OAuthQQUserInfoError
  from rest_framework.response import Response
  
  
  class OAuthQQAPIView(APIView):
      def get(self, request):
          """生成QQ登录的地址"""
          state = request.query_params.get('state')  # 客户端指定的状态
          oauth = OAuthQQ(state=state)
          url = oauth.auth_url
          return Response(url)
  
  
  from itsdangerous import TimedJSONWebSignatureSerializer as TJWSerializer
  from django.conf import settings
  from .models import OAuthUser
  from users.models import User
  from rest_framework.status import *
  from .serializers import UserModelSerializer
  
  
  class QQInfoAPIView(APIView):
  
      def response_token(self, user):
          """返回jwt"""
          from rest_framework_jwt.settings import api_settings
          jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
          jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER
  
          payload = jwt_payload_handler(user)
          token = jwt_encode_handler(payload)
          # 这里返回的信息格式参照jwt登录成功后自定义返回的信息格式
          return Response({
              "token": token,
              'id': user.id,
              'username': user.username,
              'avatar': "" if not user.avatar else user.avatar.url,
              'nickname': user.nickname,
          })
  
      def get_jws_data(self, request):
          qq_user_data = request.data.get("qq_user_data")
          jws = TJWSerializer(secret_key=settings.SECRET_KEY, expires_in=300)
          data = jws.loads(qq_user_data)
          access_token = data.get("access_token")
          refresh_token = data.get("refresh_token")
          openid = data.get("openid")
          return access_token, refresh_token, openid
  
      def get(self, request):
          """获取QQ用户的信息"""
          # 1. 获取客户端转发过来的QQ登录授权码
          code = request.query_params.get("code")
          state = request.query_params.get('state')  # 客户端指定的状态
          if not code:
              return Response("QQ登录异常！请重新尝试登录！")
  
          oauth = OAuthQQ(state=state, code=code)
          try:
              # 2. 根据授权码到QQ服务器获取access_token
              access_token = oauth.access_token
              refresh_token = oauth.refresh_token
              print(access_token)
              print(refresh_token)
              # 3. 根据access_token获取用户信息[openID]
              openid = oauth.open_id
              print(openid)
              # 3.1 获取用户信息
              qq_user_info = oauth.qq_user_info
              # 3D4B8341680E3424F8058AD5A09D7474
  ```

  













#### 路由配置

+ 总路由urls

  ```python
  path('oauth/', include("oauth.urls")),
  ```

+ 子应用路由

  ```python
  from django.urls import path
  from . import views
  urlpatterns = [
      path("qq/url/", views.OAuthQQAPIView.as_view() ),
      path("qq/info/", views.QQInfoAPIView.as_view() ),
  ]
  ```

  



### 客户端代码实现

#### 客户端请求获取QQ第三方登录地址

修改Login.vue，，在methods中增加qq_login方法

```vue
<template>
    <div class="sign">
    <div class="logo"><router-link to="/"><img src="/static/image/nav-logo.png" alt="Logo"></router-link></div>
    <div class="main">


<h4 class="title">
  <div class="normal-title">
    <router-link class="active" to="/user/login">登录</router-link>
    <b>·</b>
    <router-link id="js-sign-up-btn" class="" to="/user/register">注册</router-link>
  </div>
</h4>
<div class="js-sign-in-container">
  <form id="new_session" action="" method="post">
      <div class="input-prepend restyle js-normal">
        <input placeholder="手机号或邮箱" type="text" v-model="username" id="session_email_or_mobile_number">
        <i class="iconfont ic-user"></i>
      </div>
    <!-- 海外登录登录名输入框 -->

    <div class="input-prepend">
      <input placeholder="密码" type="password" v-model="password" id="session_password">
      <i class="iconfont ic-password"></i>
    </div>
    <div class="remember-btn">
      <input type="checkbox" value="true" checked="checked" v-model="remember_me" id="session_remember_me"><span>记住我</span>
    </div>
    <div class="forget-btn">
      <a class="" data-toggle="dropdown" href="">登录遇到问题?</a>
    </div>
    <button class="sign-in-button" id="sign-in-form-submit-btn" type="button" @click="show_captcha">
      <span id="sign-in-loading"></span>
      登录
    </button>
</form>
  <!-- 更多登录方式 -->
  <div class="more-sign">
    <h6>社交帐号登录</h6>
    <ul>
  <li id="weibo-link-wrap" class="">
    <a class="weibo" id="weibo-link">
      <i class="iconfont ic-weibo"></i>
    </a>
  </li>
  <li><a id="weixin" class="weixin" target="_blank" href=""><i class="iconfont ic-wechat"></i></a></li>
  <li><a id="qq" class="qq" target="_blank" href="" @click.prevent="qq_login"><i class="iconfont ic-qq_connect"></i></a></li>
</ul>
  </div>
</div>

    </div>
  </div>
</template>

<script>
    export default {
        name: "Login",
        data(){
            return {
                username:"",
                password:"",
                remember_me: false,
            }
        },
        methods:{
            loginHandler(){
                // 1. 验证数据[账号密码]
                if(this.username.length<1 || this.password.length<1){
                    this.$message.error("对不起,账号或密码不能为空!");
                    return ;
                }

                // 2. 发送ajax请求服务端
                this.$axios.post(`http://api.renran.cn:8000/users/login/`,{
                    username: this.username,
                    password: this.password,
                }).then(response=>{ // javascript最新语法中, 可以使用箭头函数
                    // 3. 接收服务端返回的结果[jwt]
                    // 根据用户是否勾选了remember_me[记住我]来使用本地存储保存用户的jwt
                    if(this.remember_me){
                        // 永久存储[一天]
                        localStorage.user_token = response.data.token;
                        localStorage.user_name = response.data.username;
                        localStorage.user_id = response.data.id;
                        localStorage.user_nickname = response.data.nickname;
                        localStorage.user_avatar = response.data.avatar;
                        sessionStorage.removeItem("user_token");
                        sessionStorage.removeItem("user_name");
                        sessionStorage.removeItem("user_id");
                        sessionStorage.removeItem("user_nickname");
                        sessionStorage.removeItem("user_avatar");
                    }else{
                        // 临时存储
                        sessionStorage.user_token = response.data.token;
                        sessionStorage.user_name = response.data.username;
                        sessionStorage.user_id = response.data.id;
                        sessionStorage.user_nickname = response.data.nickname;
                        sessionStorage.user_avatar = response.data.avatar;
                        localStorage.removeItem("user_token");
                        localStorage.removeItem("user_name");
                        localStorage.removeItem("user_id");
                        localStorage.removeItem("user_nickname");
                        localStorage.removeItem("user_avatar");
                    }

                    // 登录跳转
                    this.$confirm(`${response.data.nickname},欢迎回到荏苒~`, '登录成功', {
                      confirmButtonText: '去个人中心',
                      cancelButtonText: '返回上一页',
                      type: 'success'
                    }).then(() => {
                      // 跳转到个人中心
                      this.$router.push("/user");
                    }).catch(() => {
                      // 跳转到上一页
                      this.$router.back(); // this.$router.go(-1);
                    });

                }).catch(error=>{
                    if(error.response){
                        if(error.response.status==400){
                            this.$message.error("提交数据有误,请检查您输入的账号密码是否正确!");
                        }
                    }else{
                        console.log(error);
                    }

                });

            },
            show_captcha(){
                // 显示验证码

                if(this.username.length<1 || this.password.length<1){
                    this.$message.error("对不起,账号或密码不能为空!");
                    return ;
                }

                var captcha1 = new TencentCaptcha(this.$settings.TC_captcha.app_id, res=>{
                    /*
                    * ret	      Int	      验证结果，0：验证成功。2：用户主动关闭验证码。
                      ticket	  String	  验证成功的票据，当且仅当 ret = 0 时 ticket 有值。
                      appid	    String	  场景 ID。
                      bizState	Any	      自定义透传参数。
                      randstr	  String	 本次验证的随机串，请求后台接口时需带上。
                    *
                    * */
                    if(res.ret === 0){
                      this.$axios.post(`${this.$settings.Host}/users/captcha/`,{
                          ret: res.ret,
                          ticket: res.ticket,
                          randstr: res.randstr,
                      }).then(response=>{
                          if(response.data.message && response.data.randstr === res.randstr){
                              // 验证成功
                              this.loginHandler();
                          }else{
                              this.$meesage.error("验证码验证失败!请重新操作验证码");
                              captcha1.destroy();
                          }
                      }).catch(error=>{
                          console.log("发生错误!", error);
                      })
                    }

                });
                captcha1.show();
            },
            qq_login(){
                // 跳转到QQ第三方登录页面
                this.$axios.get(`${this.$settings.Host}/oauth/qq/url/`,{
                    params: {
                        state: "/",
                    }
                }).then(response=>{
                    let url = response.data;
                    // 跳转到登录页面
                    location.href = url;
                }).catch(error=>{
                    this.$message.error("网络错误!无法使用QQ登录!");
                });
            }
        }
    }
</script>

```

然后用户此时就可以在页面中通过点击跳转到QQ第三方登录页面了。

##### BUG解决

如果实现上面代码以后QQ页面出现如下错误信息：

`对不起，该网站尚未开通QQ帐号登录（错误码：100008）`

则表示当前站点应用没有通过审核。这表示我们的代码没有问题了，但是注册的应用是没通过或者审核中的。

解决方案：使用以下QQ登录应用进行测试开发。

```python
# 1. 在settings/dev.py文件中修改QQ第三方登录配置。
	# QQ登录参数
    QQ_APP_ID = '101403367'
    QQ_APP_KEY = '93112df14c10d6fde74baa62f5de95ab'
    QQ_REDIRECT_URL = 'http://www.moluo.net:8080/oauth_callback.html'
    QQ_STATE = "/" # 用于保存登录成功后的跳转页面路径
    
# 2. 在/etc/hosts/中添加如下配置信息：
    # sudo vim /etc/hosts
    127.0.0.1   www.moluo.net

# 3. 在客户端项目中临时修改config/index.js中的host域名为：www.moluo.net
#    并重启客户端项目

# 4. 在api服务端项目的配置文件settings/dev.py中，添加www.moluo.net到CORS_ORIGIN_WHITELIST列表中，并重启服务端项目
     CORS_ORIGIN_WHITELIST = (
    	'http://www.moluo.net:8080',
     )

```

经过上面的提供的操作，用户在QQ登录成功后，QQ会将用户重定向回我们配置的回调域网址，我们申请QQ登录开发资质时配置的回调地址为：`http://www.renran.cn:8080/login/qq_callback`或者`http://www.moluo.net:8080/oauth_callback.html`。



#### QQCallBack组件页面

接下来，我们要在客户端对提供一个QQCallBack组件页面，地址绑定为`oauth_callback.html`。

```vue
<template>
    
</template>

<script>
    export default {
        name: "QQCallBack"
    }
</script>

<style scoped>

</style>


```

路由router/index.js中绑定路由

```javascript
import Vue from 'vue'
import Router from 'vue-router'

Vue.use(Router);

import QQCallBack from "@/components/QQCallBack"


export default new Router({
  mode: "history",
  routes: [
 	// .....
      {
       name:"QQCallBack",
       path:"/oauth_callback.html",// 改成自己注册QQ登录时的地址,不是一定要.html,只是我当初不小心加了而已
       component: QQCallBack,
     },
  ]
})


```

接收地址栏上面的code参数转发到服务端，服务端再次请求QQ服务器提取访问QQ用户信息的access_token。

客户端代码：

```vue
<template>
    <div>
      QQ回调地址
    </div>
</template>

<script>
    export default {
        name: "QQCallBack",
        data(){

        },
        created(){
            this.get_user_info();
        },
        methods:{
            get_user_info(){

                // 转发code提供给服务端
                this.$axios.get(`${this.$settings.Host}/oauth/qq/info/`+location.search
                ).then(response=>{
                   //
                    console.log("ok");
                }).catch(error=>{
                   this.$message.error("网络错误!无法使用QQ第三方登陆");
                });
            }
        }
    }
</script>

<style scoped>

</style>
```



### 第三方登录后的三种情况

接下来根据openID是否保存在数据库中，用户会存在以下三种情况：

> 1. 用户有账号，也非第一次使用QQ登录，则直接保存用户的登录状态完成QQ登录即可。
> 2. 用户有账号，属于第一次使用QQ登录，则直接进入用户账号和QQ的绑定阶段
> 3. 用户没有账号，则直接进入用户账号和QQ的绑定阶段，并且需要根据用户信息创建一个用户出来。

#### itsdangerours模块介绍

绑定QQ过程过程中， 我们需要发送关于QQ用户的一些信息到客户端中， 所以为了保证信息安装不会被客户端篡改，我们可以选择使用itsdangerours模块来把数据进行加密。

itsdangerours模块，常用于对数据进行加密和解密。工作中，有时表单里面有些信息是服务器提供，不希望被客户端传单，可以设置使用该模块加密或者也可以用于完成一些例如找回密码等功能。

官网：`https://itsdangerous.palletsprojects.com/en/1.1.x/`

使用文档：`https://itsdangerous.palletsprojects.com/en/1.1.x/jws/`

```vue
pip install -U itsdangerous
```

接下来我们就可以根据文档使用itsdangerous对openID，access_token等数据进行加密返回给客户端保存。

#### 序列化器

oauth/serializers.py

```python
#参考原先的用户注册序列化器
from rest_framework import serializers
from .models import User
import re
from django_redis import get_redis_connection
from redis import Redis
class UserModelSerializer(serializers.ModelSerializer):
    """用户信息序列化器"""
    sms_code = serializers.CharField(required=True, write_only=True,min_length=4, max_length=4, help_text="短信验证码")
    token = serializers.CharField(read_only=True, help_text="jwt登录认证")
    class Meta:
        model = User
        fields = ["id","username","avatar","mobile","password","nickname","sms_code","token"]
        read_only_fields = ("id","username","avatar")
        extra_kwargs = {
            "mobile":{"required":True, "write_only":True, },
            "password":{"required":True, "write_only":True, "max_length": 16, "min_length": 6},
            "nickname":{"required":True }
        }


    def validate_mobile(self,mobile):
        # 验证手机号码是否格式正确
        if not re.match("^1[3-9]\d{9}$", mobile):
            raise serializers.ValidationError("手机号码格式错误！")
        # 验证手机号是否注册了
        try:
            User.objects.get(mobile=mobile)
            raise serializers.ValidationError("手机号码被占用！")
        except User.DoesNotExist:
            pass
        return mobile

    def validate_nickname(self,nickname):
        # 昵称是否被注册了
        try:
            User.objects.get(nickname=nickname)
            raise serializers.ValidationError("用户昵称被占用！")
        except User.DoesNotExist:
            pass
        return nickname

    def validate(self,attr):
        mobile = attr.get("mobile")
        sms_code = attr.get("sms_code")
        redis = get_redis_connection("sms_code")
        user_sms_code = redis.get("sms_%s" % mobile)
        print(sms_code, user_sms_code, 1111)
        if not (user_sms_code and sms_code == user_sms_code.decode()):
            raise serializers.ValidationError("验证码错误！")
        return attr



    def create(self, validated_data):
        """保存用户注册信息"""
        mobile = validated_data.get("mobile")
        nickname = validated_data.get("nickname")
        password = validated_data.get("password")
        try:
            user = User.objects.create_user(mobile=mobile, nickname=nickname, password=password,username=mobile)
        except:
            raise serializers.ValidationError("用户信息注册失败！")
        return user

```

#### views视图

```python
from django.shortcuts import render

# Create your views here.
from rest_framework.views import APIView
from .utils import OAuthQQ, OAuthQQTokenError, OAuthQQOpenIDError, OAuthQQUserInfoError
from rest_framework.response import Response


class OAuthQQAPIView(APIView):
    def get(self, request):
        """生成QQ登录的地址"""
        state = request.query_params.get('state')  # 客户端指定的状态
        oauth = OAuthQQ(state=state)
        url = oauth.auth_url
        return Response(url)


from itsdangerous import TimedJSONWebSignatureSerializer as TJWSerializer
from django.conf import settings
from .models import OAuthUser
from users.models import User
from rest_framework.status import *
from .serializers import UserModelSerializer


class QQInfoAPIView(APIView):

    def response_token(self, user):
        """返回jwt"""
        from rest_framework_jwt.settings import api_settings
        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER

        payload = jwt_payload_handler(user)
        token = jwt_encode_handler(payload)
        # 这里返回的信息格式参照jwt登录成功后自定义返回的信息格式
        return Response({
            "token": token,
            'id': user.id,
            'username': user.username,
            'avatar': "" if not user.avatar else user.avatar.url,
            'nickname': user.nickname,
        })

    def get_jws_data(self, request):
        #使用itsdangerours模块对数据进行解密获取数据
        qq_user_data = request.data.get("qq_user_data")
        jws = TJWSerializer(secret_key=settings.SECRET_KEY, expires_in=300)
        data = jws.loads(qq_user_data)
        access_token = data.get("access_token")
        refresh_token = data.get("refresh_token")
        openid = data.get("openid")
        return access_token, refresh_token, openid

    def get(self, request):
        """获取QQ用户的信息"""
        # 1. 获取客户端转发过来的QQ登录授权码
        code = request.query_params.get("code")
        state = request.query_params.get('state')  # 客户端指定的状态
        if not code:
            return Response("QQ登录异常！请重新尝试登录！")

        oauth = OAuthQQ(state=state, code=code)
        try:
            # 2. 根据授权码到QQ服务器获取access_token
            access_token = oauth.access_token
            refresh_token = oauth.refresh_token
            print(access_token)
            print(refresh_token)
            # 3. 根据access_token获取用户信息[openID]
            openid = oauth.open_id
            print(openid)
            # 3.1 获取用户信息
            qq_user_info = oauth.qq_user_info
            # 3D4B8341680E3424F8058AD5A09D7474


        except OAuthQQTokenError:
            return Response({"message": "获取access_token错误!"})
        except OAuthQQOpenIDError:
            return Response({"message": "获取openid错误!"})
        except OAuthQQUserInfoError:
            return Response({"message": "获取用户信息失败!!"})
        except:
            return Response({"message": "网络错误!QQ登陆失败!"})

        print(qq_user_info)
        # return Response('OK')
        # 4. 根据openID到数据库中查询用户判断是否属于第一次使用QQ登录
        try:
            # 情况1：当前用户有账号并且属于非第一次QQ登陆
            qq_user = OAuthUser.objects.get(openid=openid, is_delete=False)

            # 修改openid对应用户的access_token以及refresh_token的值
            qq_user.access_token = access_token
            qq_user.refresh_token = refresh_token
            qq_user.save()
            return self.response_token(qq_user.user)
            # return Response({"user_info": user_info, "status": 1})
        except OAuthUser.DoesNotExist:
            # 如果没有查到用户,则表示用户属于第一次QQ登陆,接下来就要前端页面让用户进入账号绑定阶段
            # 使用itsdangerours对openID进行加密
            data = {
                "openid": openid,
                "access_token": access_token,
                "refresh_token": refresh_token,
            }
            #使用itsdangerours模块对数据进行加密
            jws = TJWSerializer(secret_key=settings.SECRET_KEY, expires_in=300)
            result = jws.dumps(data)
            #将下次请求需要的数据发给前端
            return Response(result)

    def put(self, request):
        """已有平台账号,属于第一次QQ登陆,账号绑定QQ"""
        # 1. 获取客户端提交的账号信息
        username = request.data.get("username")
        password = request.data.get("password")
        # 使用itsdangerours模块对数据进行解密获取qq用户的相关信息
        access_token, refresh_token, openid = self.get_jws_data(request)
        try:
            user = User.objects.get(username=username)
            ret = user.check_password(password)
            if not ret:
                return Response("对不起, 账号或密码错误!", status=HTTP_400_BAD_REQUEST)
        except User.DoesNotExist:
            return Response("对不起,当前账号不存在!", status=HTTP_400_BAD_REQUEST)

        # 2. 添加账号和QQ的绑定记录
        try:
            OAuthUser.objects.create(
                name="QQ用户",
                orders=1,
                user=user,
                openid=openid,
                access_token=access_token,
                refresh_token=refresh_token,
            )
        except:
            return Response("QQ和账号绑定失败!请联系客服工作人员!", status=HTTP_500_INTERNAL_SERVER_ERROR)

        # 3. 返回jwt
        return self.response_token(user)

    def post(self, request):
        """把用户注册的新账号和QQ用户进行绑定"""
        # 1. 接受数据[账号,手机,验证码和密码]
        nickname = request.data.get("nickname")
        mobile = request.data.get("mobile")
        sms_code = request.data.get("sms_code")
        password = request.data.get("password")
        # 解密获取qq用户的相关信息
        access_token, refresh_token, openid = self.get_jws_data(request)

        # 2. 验证数据，3.添加用户信息 通过序列化器完成
        data = {
            "nickname": nickname,
            "password": password,
            "mobile": mobile,
            "sms_code": sms_code,
        }
        serializer = UserModelSerializer(data=data)
        if serializer.is_valid():
            user = serializer.save()
        else:
            return Response(serializer.errors,status=HTTP_400_BAD_REQUEST)


        # 4. 绑定QQ
        try:
            OAuthUser.objects.create(
                name="QQ用户",
                orders=1,
                user=user,
                openid=openid,
                access_token=access_token,
                refresh_token=refresh_token,
            )
        except:
            return Response("QQ和账号绑定失败!请联系客服工作人员!", status=HTTP_500_INTERNAL_SERVER_ERROR)

        # 5. 返回jwt
        return self.response_token(user)

```

#### 前端代码

settings.js代码【封装常用代码】

```javascript
export default {
  Host: "http://api.renran.cn:8085",
  TC_captcha: {
    app_id: "2086888489",
  },
  save_user(storage, data) {
    if (storage === sessionStorage) {
      var storage2 = localStorage;
    } else {
      var storage2 = sessionStorage;
    }

    storage2.removeItem("user_token");
    storage2.removeItem("user_name");
    storage2.removeItem("user_id");
    storage2.removeItem("user_nickname");
    storage2.removeItem("user_avatar");

    storage.user_token = data.token;
    storage.user_name = data.username;
    storage.user_id = data.id;
    storage.user_nickname = data.nickname;
    storage.user_avatar = data.avatar;
  },
  jump_page(vm, nickname, title = "登陆成功", confirm_text = "个人中心", confirm_url = "/user", cancel_text = "返回上一页") {
    vm.$confirm(`${nickname},欢迎回到荏苒~`, title, {
      confirmButtonText: confirm_text,
      cancelButtonText: cancel_text,
      type: 'success'
    }).then(() => {
      // 跳转到个人中心
      vm.$router.push(confirm_url);
    }).catch(() => {
      // 跳转到上一页
      vm.$router.back();
    });
  }
}
```

QQCallBack组件页面

```vue
<template>
  <div v-show="show_page">
    <div class="sign">
      <div class="logo"><a href="/"><img src="/static/image/nav-logo.png" alt="Logo"></a></div>
      <div class="main">
        <h4 class="title">
          <div class="normal-title">
            <a :class="status==1?'active':''" @click="status=1">已有账号</a>
            <b>·</b>
            <a :class="status==2?'active':''" @click="status=2">没有账号</a>
          </div>
        </h4>
        <div class="js-sign-in-container" v-if="status==1">
          <form action="" method="post">
            <div class="input-prepend restyle js-normal">
              <input placeholder="登录账号或手机号或邮箱" type="text" v-model="username">
              <i class="iconfont ic-user"></i>
            </div>
            <div class="input-prepend">
              <input placeholder="密码" type="password" v-model="password">
              <i class="iconfont ic-password"></i>
            </div>
            <div class="forget-btn">
              <router-link to="/find_password">通过邮箱找回密码?</router-link>
            </div>
            <button class="sign-in-button" type="button" @click.prevent="show_captcha">
              <span></span>登录绑定
            </button>
          </form>
        </div>
        <div class="js-sign-in-container" v-if="status==2">
          <form class="new_user" id="new_user" action="" accept-charset="UTF-8" method="post">
            <div class="input-prepend restyle">
              <input placeholder="你的昵称" type="text" value="" v-model="nickname" id="user_nickname">
              <i class="iconfont ic-user"></i>
            </div>
            <div class="input-prepend restyle no-radius js-normal">
              <input placeholder="手机号" type="tel" v-model="mobile" id="user_mobile_number" @blur="mobile_duplicate_check">
              <i class="iconfont ic-phonenumber"></i>
            </div>
            <div class="input-prepend restyle no-radius security-up-code js-security-number" v-if="is_show_sms_code">
              <input type="text" v-model="sms_code" id="sms_code" placeholder="手机验证码">
              <i class="iconfont ic-verify"></i>
              <a tabindex="-1" class="btn-up-resend js-send-code-button" href="javascript:void(0);" id="send_code"
                 @click.prevent="send_sms_code" :class="{disable:send_able}">{{sms_code_text}}</a>
            </div>
            <input type="hidden" name="security_number" id="security_number">
            <div class="input-prepend">
              <input placeholder="设置密码" type="password" v-model="password" id="user_password">
              <i class="iconfont ic-password"></i>
            </div>
            <input type="submit" name="commit" value="注册" class="sign-up-button" id="sign_up_btn"
                   @click.prevent="registerHandler">
            <p class="sign-up-msg">点击 “注册” 即表示您同意并愿意遵守荏苒<br> <a target="_blank" href="">用户协议</a> 和 <a target="_blank"
                                                                                                      href="">隐私政策</a> 。
            </p>
          </form>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
    export default {
        name: "QQCallBack",
        data() {
            return {
                show_page: false,
                status: 1, // 当前用户是否拥有了平台账号
                username: "",
                password: "",
                nickname: "",
                mobile: "",
                sms_code: "",
                sms_code_text: "发送验证码",
                is_show_sms_code: false,
                send_able: false,
                qq_user_data: "", // 用户相关信息
            }
        },
        watch: {
            mobile() {
                this.mobile_check()
            }
        },
        created() {
            this.get_user_info();
        },
        methods: {
            mobile_check() {
                if (/^1[3-9]\d{9}$/.test(this.mobile)) {
                    this.is_show_sms_code = true;

                } else {
                    this.is_show_sms_code = false;
                }
            },
            mobile_duplicate_check() {
                if (this.is_show_sms_code) {
                    this.$axios.post(`${this.$settings.Host}/users/mobile_check/`, {
                        mobile: this.mobile,
                    }).then(response => {
                        return
                    }).catch(error => {
                        if (error.response.status === 400) {
                            this.$message.error("该手机号已注册");
                        } else {
                            this.$message.error("手机号格式错误");
                        }

                        this.is_show_sms_code = false;
                    })
                }
            },
            get_user_info() {
                // 转发code提供给服务端
                this.$axios.get(`${this.$settings.Host}/oauth/qq/info/` + location.search
                ).then(response => {
                    if (response.data.token) {
                        // 当前用户有账号并且属于非第一次QQ登陆
                        this.$settings.save_user(sessionStorage, response.data);
                        this.$settings.jump_page(this, response.data.nickname);
                    } else {
                        // 当前用户属于第一次QQ登陆,显示账号绑定页面
                        this.show_page = true; // 界面内容显示出来
                        this.qq_user_data = response.data; //接收itsdangerours加密字符串

                    }
                }).catch(error => {
                    this.$message.error("网络错误!无法使用QQ第三方登陆");
                });
            },
            show_captcha() {
                if (!(this.username && this.password)) {
                    this.$message.error("账号或密码不能为空！");
                    return
                }
                var captcha1 = new TencentCaptcha(this.$settings.TC_captcha.app_id, res => {
                    // console.log(res);
                    if (res.ret === 0) {
                        // 随机码
                        // api服务端校验验证码的结果
                        this.$axios.post(`${this.$settings.Host}/users/captcha/`, {
                            ticket: res.ticket,
                            randstr: res.randstr,
                        }).then(response => {
                            // 进行登录处理
                            console.log("success");
                            if (response.data === 'success') {
                                // console.log("success");
                                this.loginHandler();
                            }
                        }).catch(error => {
                            console.log("error", error);
                            this.$message.error("验证码校验错误！");
                        })
                    }
                });
                captcha1.show();
            },
            loginHandler() {
                // 登陆账号完成QQ的绑定
                this.$axios.put(`${this.$settings.Host}/oauth/qq/info/`, {
                    username: this.username,
                    password: this.password,
                    qq_user_data: this.qq_user_data,
                }).then(response => {
                    this.$settings.save_user(sessionStorage, response.data);
                    this.$settings.jump_page(this, response.data.nickname);
                }).catch(error => {
                    this.$message.error(error.response.data);
                });
            },
            registerHandler() {
                // 注册账号完成QQ的绑定
                this.$axios.post(`${this.$settings.Host}/oauth/qq/info/`, {
                    nickname: this.nickname,
                    password: this.password,
                    mobile: this.mobile,
                    sms_code: this.sms_code,
                    qq_user_data: this.qq_user_data,
                }).then(response => {
                    this.$settings.save_user(sessionStorage, response.data);
                    this.$settings.jump_page(this, response.data.nickname);
                }).catch(error => {
                    if (error.response) {
                        if (error.response.status === 400) {
                            let error_message = '';
                            for (var i in error.response.data) {
                                error_message += error.response.data[i]
                            }
                            this.$message.error(`QQ账号绑定失败！${error_message}`);
                        } else {
                            this.$message.error(`QQ账号绑定失败！${error.response}`);
                            console.log(error);
                        }
                    }
                });
            },
            send_sms_code() {
                if (!this.send_able) {
                    this.$axios.get(`${this.$settings.Host}/users/sms/${this.mobile}/`
                    ).then(response => {
                        this.$message.success(response.data.message);
                        this.send_able = true;
                        // 显示发送短信以后的文本倒计时
                        let time = 60;
                        let t = setInterval(() => {
                            if (--time <= 1) {
                                // 如果倒计时为0,则关闭当前定时器
                                this.sms_code_text = "发送验证码";
                                this.send_able = false;
                                clearInterval(t);
                                time = 60;
                            } else {
                                this.sms_code_text = `${time}秒后重新点击`;
                            }
                        }, 1000);
                    }).catch(error => {
                        this.$message.error(error.response.data.message);
                    })
                }
            },
        }
    }
</script>

<style scoped>
  input {
    outline: none;
  }

  *, :after, :before {
    box-sizing: border-box;
  }

  .sign {
    height: 100%;
    min-height: 750px;
    text-align: center;
    font-size: 14px;
    background-color: #f1f1f1
  }

  .sign:before {
    content: "";
    display: inline-block;
    height: 85%;
    vertical-align: middle
  }

  .sign .disable, .sign .disable-gray {
    opacity: .5;
    pointer-events: none
  }

  .sign .disable-gray {
    background-color: #969696
  }

  .sign .tooltip-error {
    font-size: 14px;
    line-height: 25px;
    white-space: nowrap;
    background: none
  }

  .sign .tooltip-error .tooltip-inner {
    max-width: 280px;
    color: #333;
    border: 1px solid #ea6f5a;
    background-color: #fff
  }

  .sign .tooltip-error .tooltip-inner i {
    position: static;
    margin-right: 5px;
    font-size: 20px;
    color: #ea6f5a;
    vertical-align: middle
  }

  .sign .tooltip-error .tooltip-inner span {
    vertical-align: middle;
    display: inline-block;
    white-space: normal;
    max-width: 230px
  }

  .sign .tooltip-error.right .tooltip-arrow-border {
    border-right-color: #ea6f5a
  }

  .sign .tooltip-error.right .tooltip-arrow-bg {
    left: 2px;
    border-right-color: #fff
  }

  .sign .slide-error {
    position: relative;
    padding: 10px 0;
    border: 1px solid #c8c8c8;
    border-radius: 4px
  }

  .sign .slide-error i {
    position: static !important;
    margin-right: 10px;
    color: #ea6f5a !important;
    vertical-align: middle
  }

  .sign .slide-error span {
    font-size: 15px;
    vertical-align: middle
  }

  .sign .slide-error div {
    margin-top: 10px;
    font-size: 13px
  }

  .sign .slide-error a {
    color: #3194d0
  }

  .sign .js-sign-up-forbidden {
    color: #999;
    padding: 80px 0 100px
  }

  .sign .js-sign-up-container .slide-error {
    border-bottom: none;
    border-radius: 0
  }

  .sign .logo {
    position: absolute;
    top: 56px;
    margin-left: 50px
  }

  .sign .logo img {
    width: 100px
  }

  .sign .main {
    width: 400px;
    margin: 60px auto 0;
    padding: 50px 50px 30px;
    background-color: #fff;
    border-radius: 4px;
    box-shadow: 0 0 8px rgba(0, 0, 0, .1);
    vertical-align: middle;
    display: inline-block
  }

  .sign .reset-title, .sign .title {
    margin: 0 auto 50px;
    padding: 10px;
    font-weight: 400;
    color: #969696
  }

  .sign .reset-title a, .sign .title a {
    padding: 10px;
    color: #969696
  }

  .sign .reset-title a:hover, .sign .title a:hover {
    border-bottom: 2px solid #ea6f5a
  }

  .sign .reset-title .active, .sign .title .active {
    font-weight: 700;
    color: #ea6f5a;
    border-bottom: 2px solid #ea6f5a
  }

  .sign .reset-title b, .sign .title b {
    padding: 10px
  }

  .sign .reset-title {
    color: #333;
    font-weight: 700
  }

  .sign form {
    margin-bottom: 30px
  }

  .sign form .input-prepend {
    position: relative;
    width: 100%
  }

  .sign form .input-prepend input {
    width: 100%;
    height: 50px;
    margin-bottom: 0;
    padding: 4px 12px 4px 35px;
    border: 1px solid #c8c8c8;
    border-radius: 0 0 4px 4px;
    background-color: hsla(0, 0%, 71%, .1);
    vertical-align: middle
  }

  .sign form .input-prepend i {
    position: absolute;
    top: 14px;
    left: 10px;
    font-size: 18px;
    color: #969696
  }

  .sign form .input-prepend span {
    color: #333
  }

  .sign form .input-prepend .ic-show {
    top: 18px;
    left: auto;
    right: 8px;
    font-size: 12px
  }

  .sign form .geetest-placeholder {
    height: 44px;
    border-radius: 4px;
    background-color: hsla(0, 0%, 71%, .1);
    text-align: center;
    line-height: 44px;
    font-size: 14px;
    color: #999
  }

  .sign form .restyle {
    margin-bottom: 0
  }

  .sign form .restyle input {
    border-bottom: none;
    border-radius: 4px 4px 0 0
  }

  .sign form .no-radius input {
    border-radius: 0
  }

  .sign form .slide-security-placeholder {
    height: 32px;
    background-color: hsla(0, 0%, 71%, .1);
    border-radius: 4px
  }

  .sign form .slide-security-placeholder p {
    padding-top: 7px;
    color: #999;
    margin-right: -7px
  }

  .sign .overseas-btn {
    font-size: 14px;
    color: #999
  }

  .sign .overseas-btn:hover {
    color: #2f2f2f
  }

  .sign .remember-btn {
    float: left;
    margin: 15px 0
  }

  .sign .remember-btn span {
    margin-left: 5px;
    font-size: 15px;
    color: #969696;
    vertical-align: middle
  }

  .sign .forget-btn {
    float: right;
    position: relative;
    margin: 15px 0;
    font-size: 14px
  }

  .sign .forget-btn a {
    color: #999
  }

  .sign .forget-btn a:hover {
    color: #333
  }

  .sign .forget-btn .dropdown-menu {
    top: 20px;
    left: auto;
    right: 0;
    border-radius: 4px
  }

  .sign .forget-btn .dropdown-menu a {
    padding: 10px 20px;
    color: #333
  }

  .sign #sign-in-loading {
    position: relative;
    width: 20px;
    height: 20px;
    vertical-align: middle;
    margin-top: -4px;
    margin-right: 2px;
    display: none
  }

  .sign #sign-in-loading:after {
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: transparent
  }

  .sign #sign-in-loading:before {
    content: "";
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin: -10px 0 0 -10px;
    border-radius: 10px;
    border: 2px solid #fff;
    border-bottom-color: transparent;
    vertical-align: middle;
    -webkit-animation: rolling .8s infinite linear;
    animation: rolling .8s infinite linear;
    z-index: 1
  }

  .sign .sign-in-button, .sign .sign-up-button {
    margin-top: 20px;
    width: 100%;
    padding: 9px 18px;
    font-size: 18px;
    border: none;
    border-radius: 25px;
    color: #fff;
    background: #42c02e;
    cursor: pointer;
    outline: none;
    display: block;
    clear: both
  }

  .sign .sign-in-button:hover, .sign .sign-up-button:hover {
    background: #3db922
  }

  .sign .sign-in-button {
    background: #3194d0
  }

  .sign .sign-in-button:hover {
    background: #187cb7
  }

  .sign .btn-in-resend, .sign .btn-up-resend {
    position: absolute;
    top: 7px;
    right: 7px;
    width: 100px;
    height: 36px;
    font-size: 13px;
    color: #fff;
    background-color: #42c02e;
    border-radius: 20px;
    line-height: 36px
  }

  .sign .btn-in-resend {
    background-color: #3194d0
  }

  .sign .sign-up-msg {
    margin: 10px 0;
    padding: 0;
    text-align: center;
    font-size: 12px;
    line-height: 20px;
    color: #969696
  }

  .sign .sign-up-msg a, .sign .sign-up-msg a:hover {
    color: #3194d0
  }

  .sign .overseas input {
    padding-left: 110px !important
  }

  .sign .overseas .overseas-number {
    position: absolute;
    top: 0;
    left: 0;
    width: 100px;
    height: 50px;
    font-size: 18px;
    color: #969696;
    border-right: 1px solid #c8c8c8
  }

  .sign .overseas .overseas-number span {
    margin-top: 17px;
    padding-left: 35px;
    text-align: left;
    font-size: 14px;
    display: block
  }

  .sign .overseas .dropdown-menu {
    width: 100%;
    max-height: 285px;
    font-size: 14px;
    border-radius: 0 0 4px 4px;
    overflow-y: auto
  }

  .sign .overseas .dropdown-menu li .nation-code {
    width: 65px;
    display: inline-block
  }

  .sign .overseas .dropdown-menu li a {
    padding: 6px 20px;
    font-size: 14px;
    line-height: 20px
  }

  .sign .overseas .dropdown-menu li a::hover {
    color: #fff;
    background-color: #f5f5f5
  }

  .sign .more-sign {
    margin-top: 50px
  }

  .sign .more-sign h6 {
    position: relative;
    margin: 0 0 10px;
    font-size: 12px;
    color: #b5b5b5
  }

  .sign .more-sign h6:before {
    left: 30px
  }

  .sign .more-sign h6:after, .sign .more-sign h6:before {
    content: "";
    border-top: 1px solid #b5b5b5;
    display: block;
    position: absolute;
    width: 60px;
    top: 5px
  }

  .sign .more-sign h6:after {
    right: 30px
  }

  .sign .more-sign ul {
    margin-bottom: 10px;
    list-style: none
  }

  .sign .more-sign ul li {
    margin: 0 5px;
    display: inline-block
  }

  .sign .more-sign ul a {
    width: 50px;
    height: 50px;
    line-height: 50px;
    display: block
  }

  .sign .more-sign ul i {
    font-size: 28px
  }

  .sign .more-sign .ic-weibo {
    color: #e05244
  }

  .sign .more-sign .ic-wechat {
    color: #00bb29
  }

  .sign .more-sign .ic-qq_connect {
    color: #498ad5
  }

  .sign .more-sign .ic-douban {
    color: #00820f
  }

  .sign .more-sign .ic-more {
    color: #999
  }

  .sign .more-sign .weibo-loading {
    pointer-events: none;
    cursor: pointer;
    position: relative
  }

  .sign .more-sign .weibo-loading:after {
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: #fff
  }

  body.reader-night-mode .sign .more-sign .weibo-loading:after {
    background-color: #3f3f3f
  }

  .sign .more-sign .weibo-loading:before {
    content: "";
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin: -10px 0 0 -10px;
    border-radius: 10px;
    border: 2px solid #e05244;
    border-bottom-color: transparent;
    vertical-align: middle;
    -webkit-animation: rolling .8s infinite linear;
    animation: rolling .8s infinite linear;
    z-index: 1
  }

  @keyframes rolling {
    0% {
      -webkit-transform: rotate(0deg);
      transform: rotate(0deg)
    }

    to {
      -webkit-transform: rotate(1turn);
      transform: rotate(1turn)
    }
  }

  @-webkit-keyframes rolling {
    0% {
      -webkit-transform: rotate(0deg)
    }

    to {
      -webkit-transform: rotate(1turn)
    }
  }

  .sign .reset-password-input {
    border-radius: 4px !important
  }

  .sign .return {
    margin-left: -8px;
    color: #969696
  }

  .sign .return:hover {
    color: #333
  }

  .sign .return i {
    margin-right: 5px
  }

  .sign .icheckbox_square-green {
    display: inline-block;
    *display: inline;
    vertical-align: middle;
    margin: 0;
    padding: 0;
    width: 18px;
    height: 18px;
    background: url(/static/image/green.png) no-repeat;
    border: none;
    cursor: pointer;
    background-position: 0 0
  }

  .sign .icheckbox_square-green.hover {
    background-position: -20px 0
  }

  .sign .icheckbox_square-green.checked {
    background-position: -40px 0
  }

  .sign .icheckbox_square-green.disabled {
    background-position: -60px 0;
    cursor: default
  }

  .sign .icheckbox_square-green.checked.disabled {
    background-position: -80px 0
  }


  .geetest_panel_box > * {
    box-sizing: content-box
  }

  @media (max-width: 768px) {
    body {
      min-width: 0
    }

    .sign {
      height: auto;
      min-height: 0;
      background-color: transparent
    }

    .sign .logo {
      display: none
    }

    .sign .main {
      position: absolute;
      left: 50%;
      margin: 0 0 0 -200px;
      box-shadow: none
    }
  }
</style>

```



### 找回密码的实现思路

```python
第1种思路：
1. django发送邮件，邮件里面的内容，是一个重新生成的密码。
2. 后面用户查看自己的邮件，即可根据新密码进行登录。

发邮件：django内置有发送邮件的工具类，
       from django.core.mail import send_mail
       需要配置下邮箱，settings/dev.py中配置邮箱的参数【官网上面有说明】

第3种思路：
1. 发送短信，通过短信进入修改密码的页面。需要新提供一个修改密码的页面。

第3种思路：
1. 通过发送邮件，在邮件内容，保存一个链接地址，这个地址的查询字符串中附带一个使用itsdangerous加密的信息，通过加密信息，保存要找回的账号[邮箱]，新提供一个页面，然后让用户点击连接就可以跳转回到荏苒的修改密码页面，然后用户直接修改。
```



























































