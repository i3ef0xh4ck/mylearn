## **冒泡排序**

+ **算法思想**

  ```
     冒泡排序要对一个列表多次重复遍历。它要比较相邻的两项，并且交换顺序排错的项。每对 列表实行一次遍历，就有一个最大项排在了正确的位置。大体上讲，列表的每一个数据项都会在 其相应的位置 “冒泡”。如果列表有 n 项，第一次遍历就要比较 n-1 对数据。需要注意，一旦列 表中最大(按照规定的原则定义大小)的数据是所比较的数据对中的一个，它就会沿着列表一直 后移，直到这次遍历结束。
  ```

+ 代码实现

  ```python
  def bubbleSort(alist):
      n = len(alist)
      for i in range(n-1, 0, -1):
          for j in range(0, i):
              if alist[j] > alist[j+1]:#判断前者是否需要与后者调换位置
                  alist[j], alist[j+1] = alist[j+1], alist[j]
      return alist
  
  a = [1,2,4,5,9,8,6,4,3,1]
  bubbleSort(a)
  print(a)
  >>>[1, 1, 2, 3, 4, 4, 5, 6, 8, 9]
  ```

+ 代码优化

  ```python
  def bubbleSort(alist):
      n = len(alist)
      flag = True
      for i in range(n-1, 0, -1):
          for j in range(0, i):
              if alist[j] > alist[j+1]:#判断前者是否需要与后者调换位置
                  alist[j], alist[j+1] = alist[j+1], alist[j]
                  flag = False #若没有进行交换则flag不变，说明已经排好
          if flag:
              return alist
  
  a = [1,2,4,5,9,8,6,4,3,1]
  bubbleSort(a)
  print(a)
  >>>[1, 1, 2, 3, 4, 4, 5, 6, 8, 9]
  ```

  

## **选择排序**

+ **算法思想**

  ```
     选择排序提高了冒泡排序的性能，它每遍历一次列表只交换一次数据，即进行一次遍历时找到最大的项，完成遍历后，再把它换到正确的位置。
     和冒泡排序一样，第一次遍历后，最大的数据项就已归位，第二次遍历使次大项归位。
     这个过程持续进行，一共需要 n-1 次遍历来排好 n 个数据，因为最后一个数据必须在第 n-1 次遍历之后才能归位。
  ```

+ 代码实现

  ```python
  def selectionSort(alist):
      n = len(alist)
  
      for i in range(n-1,0,-1):
          max_index = i
          for j in range(i-1,0,-1):
              if alist[j] > alist[max_index]:
                  max_index = j
          alist[i], alist[max_index] = alist[max_index], alist[i]
      return alist
  
  print(selectionSort([1,2,4,5,9,8,6,4,3,1]))
  ```

  