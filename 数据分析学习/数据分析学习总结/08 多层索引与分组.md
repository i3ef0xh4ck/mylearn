# MultiIndex

MultiIndex，即具有多个层次的索引，有些类似于根据索引进行分组的形式。通过多层次索引，我们就可以使用高层次的索引，来操作整个索引组的数据。

## 创建方式

### 第一种

+ 在创建Series或DataFrame时，可以通过给index（columns）参数传递二维数组，进而构建多维索引。

+ 数组中每个维度（一维数组）对应位置的元素，组成每层的索引值

  + 除最后一层外其余层连续层级索引会进行合并显示

  ```python
  s = pd.Series([1,2,3,4],index=[['海淀区','海淀区','昌平区','昌平区'],['上半年','上半年','下半年','下半年']])
  s
  --------------------------
  海淀区  上半年    1
         上半年    2
  昌平区  下半年    3
         下半年    4
  dtype: int64
  ```

  ```python
  pd.DataFrame(np.random.rand(4,4),index=[['a','a','b','b'],[1,2,3,4]])
  
  -------------------
  
  				0		   1		   2		   3
  a	1	0.215643	0.259366	0.590072	0.597830
  	2	0.777191	0.250188	0.889355	0.069163
  b	3	0.047601	0.167168	0.604626	0.422327
  	4	0.658788	0.599731	0.996548	0.421765
  ```

  ```python
  df = pd.DataFrame(np.random.rand(4, 4), index=[["上半年", "上半年", "下半年", "下半年"], ["第一季度", "第二季度", "第三季度", "第四季度"]],columns=[["水果", "水果", "蔬菜", "蔬菜"], ["苹果", "香蕉", "白菜", "萝卜"]])
  print(df)
  print(df.index)
  print(df.columns)
  print(df.index.codes)#[[0, 0, 1, 1], [0, 2, 1, 3]]
  ---------------------------------
                  	水果                  蔬菜          
                  苹果        香蕉        白菜        萝卜
  上半年 第一季度  0.348617  0.745489  0.824814  0.574186
        第二季度  0.332535  0.361443  0.192629  0.483623
  下半年 第三季度  0.019246  0.898122  0.505198  0.633880
        第四季度  0.243195  0.033002  0.383515  0.485138
  MultiIndex([('上半年', '第一季度'),
              ('上半年', '第二季度'),
              ('下半年', '第三季度'),
              ('下半年', '第四季度')],
             )
  MultiIndex([('水果', '苹果'),
              ('水果', '香蕉'),
              ('蔬菜', '白菜'),
              ('蔬菜', '萝卜')],
             )
  ```

+ 多维索引的也可以设置名称（names属性）

  + 属性的值为一维数组，元素的个数需要与索引的层数相同（每层索引都需要具有一个名称）。

  + 当索引是单层时，可以给index的name属性赋值。

  + 当索引是多层时，可以给index的names属性赋值。（每层索引都需要具有一个名字）
  
    ```python
    s = pd.Series([1,2,3,4],index=[['a','a','b','b'],['a1','a1','b1','b1']])
    s.index.names=['outer','inner']
    print(s)
    ----------------
    outer  inner
    a      a1       1
           a1       2
    b      b1       3
           b1       4
  dtype: int64
    ```
  
    ```python
    df = pd.DataFrame(np.random.rand(4, 4), index=[["上半年", "上半年", "下半年", "下半年"], ["第一季度", "第二季度", "第三季度", "第四季度"]],columns=[["水果", "水果", "蔬菜", "蔬菜"], ["苹果", "香蕉", "白菜", "萝卜"]])
    df.index.names = ['年','季度']
    df.columns.names = ['分类','品种']
  df
    ```
  
    ![image-20200106115536363](08 多层索引与分组.assets/image-20200106115536363.png)

### 第二种

我们可以通过MultiIndex类的相关方法，预先创建一个MultiIndex对象，然后作为Series与DataFrame中的index（或columns）参数值。同时，可以通过names参数指定多层索引的名称。

- from_arrays

  - 接收一个多维数组参数，高维指定高层索引，低维指定底层索引。（一个元素指定一个层次）
  - 纵向的方式来指定索引标签（维度对应）

  ```python
  mindex = pd.MultiIndex.from_arrays([["上半年", "上半年", "下半年", "下半年"], ["第一季度", "第二季度", "第三季度", "第四季度"]],names= ['年','季度'])
  df = pd.DataFrame(np.random.rand(4, 4), index=mindex)
  print(mindex)
  -------------------
  MultiIndex([('上半年', '第一季度'),
              ('上半年', '第二季度'),
              ('下半年', '第三季度'),
              ('下半年', '第四季度')],
             names=['年', '季度'])
  ```

  

- from_tuples

  - 接收一个元组的列表，每个元组指定每个索引（高维索引，低维索引）。
  - 横向的方式来指定索引标签（元组元素对应）

  ```python
  mindex = pd.MultiIndex.from_tuples([('上半年','第一季度'),('上半年','第二季度'),('下半年','第三季度'),('下半年','第四季度')],names= ['年','季度'])
  df = pd.DataFrame(np.random.rand(4, 4), index=mindex)
  print(mindex)
  ----------------
  MultiIndex([('上半年', '第一季度'),
              ('上半年', '第二季度'),
              ('下半年', '第三季度'),
              ('下半年', '第四季度')],
             names=['年', '季度'])
  ```

- from_product

  - 接收一个可迭代对象的列表，根据多个可迭代对象元素的笛卡尔积进行创建索引。
- from_product相对于前两个方法而言，实现相对简单，但是，也存在局限。（必须每种组合都要存在）
  
  ```python
  mindex = pd.MultiIndex.from_product([['上半年','下半年'],['第一季度','第二季度']])
  df = pd.DataFrame(np.random.rand(4, 4), index=mindex)
  print(mindex)
  --------------------
  MultiIndex([('上半年', '第一季度'),
              ('上半年', '第二季度'),
              ('下半年', '第一季度'),
              ('下半年', '第二季度')],
             )
```
  
  

## 多层索引操作

对于多层索引，同样也支持单层索引的相关操作，例如，索引元素，切片，索引数组选择元素等。我们也可以根据多级索引，按层次逐级选择元素。
**多层索引的优势**：通过创建多层索引，我们就可以使用高层次的索引，来操作整个索引组的数据。
格式：

- s[操作]
- s.loc[操作]
- s.iloc[操作]

其中，操作可以是索引，切片，数组索引，布尔索引。

### Series多层索引

- 通过loc（标签索引）操作，可以通过多层索引，获取该索引所对应的一组值。

  ```python
  s = pd.Series([11,12,13,14],index= [['a','a','b','b'],[1,2,3,4]])
  display(s)
  s.loc['a']
  ----------------
  a  1    11
     2    12
  b  3    13
     4    14
  dtype: int64
  
  1    11
  2    12
  dtype: int64
  ```

  - 根据标签，向下延伸

    ```python
    s.loc['a',2]#12
    ```

    

- 通过iloc（位置索引）操作，会获取对应位置的元素值（与是否多层索引无关）。

  ```python
  s.iloc[0]#11
  s.iloc[0:]
  --------------
  a  1    11
     2    12
  b  3    13
     4    14
  dtype: int64
  ```

- 通过标签数组访问

  ```python
  s.loc[['a','b']]
  --------------
  a  1    11
     2    12
  b  3    13
     4    14
  dtype: int64
  ```

- 通过布尔数组访问。（与是否多层索引无关-必须知道每一个位置）

  ```python
  s.loc[[True,False,True,False]]
  ```

- 通过s[操作]的行为有些诡异，建议不用。

  - 对于索引（单级），首先按照标签选择，如果标签不存在，则按照位置选择。
  - 对于多级索引，则按照标签进行选择。
  - 对于切片，如果提供的是整数，则按照位置选择，否则按照标签选择。
  - 对于数组索引, 如果数组元素都是整数，则根据位置进行索引，否则，根据标签进行索引（此时如果标签不存在，也不会出现错误）。

### DataFrame多层索引

- 通过loc（标签索引）操作，可以通过多层索引，获取该索引所对应的一组值。

  ```python
  df = pd.DataFrame(np.random.rand(4,4),index=[['a','a','b','b'],['c','d','e','f']])
  display(df)
  df.loc['a']
  ---------------------------
  			0		   1		    2		   3
  a	c	0.337932	0.353303	0.144424	0.037060
  	d	0.388199	0.612935	0.711696	0.876810
  b	e	0.099278	0.534530	0.812676	0.346897
  	f	0.119166	0.628002	0.302747	0.502832
  		0			1			2			3
  c	0.337932	0.353303	0.144424	0.03706
  d	0.388199	0.612935	0.711696	0.87681
  -------------------------------
  df.loc['a','c']
  --------------
  0    0.552098
  1    0.905847
  2    0.282634
  3    0.677763
  Name: (a, c), dtype: float64
  ```

  

- 通过iloc（位置索引）操作，会获取对应位置的一行（与是否多层索引无关）。

  ```python
  df = pd.DataFrame(np.random.rand(4,4),index=[['a','a','b','b'],['c','d','e','f']])
  display(df)
  df.iloc[0:2]
  ----------------------
  			0			1			2		3
  a	c	0.352029	0.410109	0.818011	0.849693
  	d	0.426979	0.621324	0.216055	0.664635
  ```

- 通过s[操作]的行为有些诡异，建议不用。

  - 对于索引，根据标签获取相应的列（如果是多层索引，则可以获得多列）。
  - 对于数组索引, 根据标签，获取相应的列（如果是多层索引，则可以获得多列）。
  - 对于切片，首先按照标签进行索引，然后再按照位置进行索引（取行）。

## 交换索引

我们可以调用DataFrame对象的swaplevel方法来交换两个层级索引。

`df.swaplevel(i=-2, j=-1, axis=0)`

+ 默认对倒数第2层与倒数第1层进行交换。

  ```python
  df = pd.DataFrame(np.random.rand(4,4),index=[['a','a','b','b'],['c','d','c','d']])
  display(df)
  df.swaplevel()
  ----------------------------
  			0			1			2			3
  a	c	0.529861	0.871674	0.578929	0.744482
  	d	0.264900	0.367921	0.072277	0.540972
  b	c	0.892239	0.576662	0.204417	0.602159
  	d	0.821630	0.811221	0.769412	0.780848
  			0			1			2			3
  c	a	0.529861	0.871674	0.578929	0.744482
  d	a	0.264900	0.367921	0.072277	0.540972
  c	b	0.892239	0.576662	0.204417	0.602159
  d	b	0.821630	0.811221	0.769412	0.780848
  ```

+ 可以指定交换的层(参考列表的索引规则-顺序没有关系)。

  + 层次从0开始，由外向内递增（或者由上到下递增）

    ```python
    df = pd.DataFrame(np.random.rand(4,4),index=[['a','a','b','b'],['c','d','c','d'],['e','f','e','f']])
    display(df)
    df.swaplevel(2,0)
    ```

  + 指定负值，负值表示倒数第n层。

+ 除此之外，我们也可以使用层次索引的名称来进行交换。

  ```python
  df = pd.DataFrame(np.random.rand(4,4),index=[['a','a','b','b'],['c','d','c','d'],['e','f','e','f']])
  df.index.names = ['level1','level2','level3']
  display(df)
  df.swaplevel('level1','level2')
  ```

  ![image-20200107141211634](08 多层索引与分组.assets/image-20200107141211634.png)

+ 通过axis指定交换行标签（0）还是列标签（1）

  ```python
  df = pd.DataFrame(np.random.rand(4,4),index=[['a','a','b','b'],['c','d','c','d'],['e','f','e','f']],
                   columns=[['k','k','l','l'],['x','y','x','y']])
  df.index.names = ['level1','level2','level3']
  display(df)
  df.swaplevel(0,1,axis=1)
  ```

  ![image-20200107141515904](08 多层索引与分组.assets/image-20200107141515904.png)

## 索引排序

使用sort_index方法对索引进行排序处理。

- level：指定根据哪一层进行排序，默认为最外（上）层。

  - 同时其内层也会在基础上进行排序

  ```python
  df = pd.DataFrame(np.random.rand(4,4),index=[['b','b','a','a'],['d','c','d','c'],['g','f','e','a']])
  display(df)
  df = df.swaplevel()
  display(df)
  df.sort_index()
  ```

  ![image-20200107142318375](08 多层索引与分组.assets/image-20200107142318375.png)

- 该值可以是数值，索引名，或者是由二者构成的列表。

  ```python
  df = pd.DataFrame(np.random.rand(4,4),index=[['b','b','a','a'],['d','c','d','c'],['g','f','e','a']])
  df.index.names=['lv1','lv2','lv3']
  display(df)
  df.sort_index(level='lv2')#level=1
  ```

  ![image-20200107142742307](08 多层索引与分组.assets/image-20200107142742307.png)

- inplace：是否就地修改。默认为False。

- ascending 参数，指定是否升序排序，默认为True。

- axis指定对行索引(0)还是列索引(1)排序。

## 索引堆叠

通过DataFrame对象的stack方法，可以进行索引堆叠，即将指定层级的列转换成行。 

+ level：指定转换的层级，默认为-1(最内的层级)。（也可使用名称，索引）
+ dropna：是否删除结果集中全部为空的行（默认为True）

```python
df = pd.DataFrame(np.random.rand(4,4),index=[['a','a','b','b'],['c','d','c','d']])
display(df)
df.stack()
```

![image-20200107143226223](08 多层索引与分组.assets/image-20200107143226223.png)

```python
df = pd.DataFrame(np.random.rand(4,4),index=[['a','a','b','b'],['c','d','c','d']],
                 columns=[['e','e','f','f'],['g','h','g','h']])
display(df)
df.stack()
```

![image-20200107143419235](08 多层索引与分组.assets/image-20200107143419235.png)

## 取消堆叠

通过DataFrame对象的unstack方法，可以取消索引堆叠，即将指定层级的行转换成列。 

+ level：指定转换的层级，默认为-1。 
+ fill_value：指定填充值（取消堆叠的过程中，可能会产生空值）。默认为NaN。

```python
df = pd.DataFrame(np.random.rand(4,4),index=[['a','a','b','b'],['c','d','c','d']],
                 columns=[['e','e','f','f'],['g','h','g','h']])
display(df)
df.unstack()
```

![image-20200107143548094](08 多层索引与分组.assets/image-20200107143548094.png)



## 设置索引

在DataFrame中，如果我们需要将现有的某一（几）列作为索引列，可以调用set_index方法来实现。

```python
df = pd.DataFrame([[1,2,3],[4,5,6]],columns=['id','x','y'])
display(df)
df.set_index('id')
---------------------
	id	x	y
0	1	2	3
1	4	5	6

	x	y
id		
1	2	3
4	5	6
```

- drop：是否丢弃作为新索引的列，默认为True。

  ```python
  df = pd.DataFrame([[1,2,3],[4,5,6]],columns=['id','x','y'])
  display(df)
  df.set_index('id',drop=False)
  ----------------------------------
  
  	id	x	y
  0	1	2	3
  1	4	5	6
  
  	id	x	y
  id			
  1	1	2	3
  4	4	5	6
  ```

- 可以将多列设置为索引列。此时，就会产生层级索引。

  ```python
  df = pd.DataFrame([[1,2,3],[4,5,6]],columns=['id','id2','y'])
  display(df)
  df.set_index(['id','id2'],drop=False)
  ------------------------
  	id	id2	y
  0	1	2	3
  1	4	5	6
  		id	id2	y
  id	id2			
  1	2	1	2	3
  4	5	4	5	6
  ```

- append：是否以追加的方式设置索引，默认为False(替换之前的索引)。

  ```python
  df = pd.DataFrame([[1,2,3],[4,5,6]],columns=['id','id2','y'])
  display(df)
  df = df.set_index('id',drop=False)
  df.set_index('id2',append=True,drop=False)
  ```

- inplace：是否就地修改，默认为False。

## 重置（取消）索引

调用在DataFrame对象的reset_index，可以重置索引。该操作与set_index正好相反。

- level：重置索引的层级，默认重置所有层级的索引。如果重置所有索引，将会创建默认整数序列索引。

  ```python
  df = pd.DataFrame([[1,2,3],[4,5,6],[7,8,9]],index=[['a','a','b'],['id','id2','y']])
  display(df)
  df.reset_index(0)
  -------------------------
  
  		0	1	2
  a	id	1	2	3
  id2	4	5	6
  b	y	7	8	9
  	level_0	0	1	2
  id		a	1	2	3
  id2		a	4	5	6
  y		b	7	8	9
  ```

- drop：是否丢弃重置的索引列(是否回归数据列)，默认为False。

- inplace：是否就地修改，默认为False。